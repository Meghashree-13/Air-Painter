<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Air Painter | Interactive Canvas</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <!-- MediaPipe Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #050505;
            margin: 0;
            overflow: hidden;
            color: #fff;
        }
        .mono { font-family: 'JetBrains Mono', monospace; }
        
        /* Custom scrollbar for instructions if needed */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 10px; }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .btn-active {
            border-color: white !important;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255,255,255,0.2);
        }

        @keyframes pulse-soft {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .animate-pulse-soft { animation: pulse-soft 2s infinite; }
    </style>
</head>
<body>
    <!-- Video Feed (Hidden) -->
    <video id="input_video" class="hidden" playsinline></video>

    <!-- Background Canvas (Video) -->
    <canvas id="bg_canvas"></canvas>

    <!-- Drawing Canvas (Persistent) -->
    <canvas id="drawing_canvas"></canvas>

    <!-- UI Overlay -->
    <div class="absolute inset-0 flex flex-col pointer-events-none p-6 md:p-10">
        <!-- Header -->
        <div class="flex justify-between items-start pointer-events-auto">
            <div class="flex flex-col gap-1">
                <h1 class="text-4xl md:text-5xl font-black tracking-tighter uppercase italic flex items-center gap-3">
                    <i data-lucide="palette" class="w-10 h-10 text-cyan-400"></i>
                    Air Painter
                </h1>
                <div class="flex items-center gap-2">
                    <div id="status_dot" class="w-2.5 h-2.5 rounded-full bg-red-500 transition-colors duration-500"></div>
                    <span id="status_text" class="text-[10px] uppercase tracking-[0.3em] font-bold opacity-40 mono">
                        Waiting for Gesture
                    </span>
                </div>
            </div>

            <!-- Controls -->
            <div class="flex flex-col md:flex-row items-center gap-4 bg-black/40 backdrop-blur-2xl p-3 rounded-3xl border border-white/10 shadow-2xl pointer-events-auto">
                <!-- Brush Size -->
                <div class="flex items-center gap-3 px-2">
                    <i data-lucide="brush" class="w-4 h-4 text-white/50"></i>
                    <input type="range" id="brush_size" min="2" max="50" value="10" class="w-24 h-1 bg-white/20 rounded-lg appearance-none cursor-pointer accent-cyan-500">
                    <span id="brush_size_val" class="text-[10px] mono w-4 text-white/50">10</span>
                </div>
                <div class="hidden md:block w-px h-8 bg-white/10"></div>
                
                <!-- Colors -->
                <div id="color_picker" class="flex gap-2 px-2">
                    <button data-color="#00ffff" class="w-8 h-8 rounded-full border-2 border-transparent transition-all duration-300 hover:scale-110 bg-[#00ffff] btn-active"></button>
                    <button data-color="#3b82f6" class="w-8 h-8 rounded-full border-2 border-transparent transition-all duration-300 hover:scale-110 bg-[#3b82f6]"></button>
                    <button data-color="#22c55e" class="w-8 h-8 rounded-full border-2 border-transparent transition-all duration-300 hover:scale-110 bg-[#22c55e]"></button>
                    <button data-color="#ef4444" class="w-8 h-8 rounded-full border-2 border-transparent transition-all duration-300 hover:scale-110 bg-[#ef4444]"></button>
                    <button data-color="#eab308" class="w-8 h-8 rounded-full border-2 border-transparent transition-all duration-300 hover:scale-110 bg-[#eab308]"></button>
                </div>
                <div class="w-px h-8 bg-white/10"></div>
                
                <!-- History & Clear -->
                <div class="flex items-center gap-1">
                    <button id="undo_btn" class="p-2 hover:bg-white/10 rounded-xl transition-colors text-white/80 hover:text-white disabled:opacity-20" title="Undo">
                        <i data-lucide="undo-2" class="w-5 h-5"></i>
                    </button>
                    <button id="redo_btn" class="p-2 hover:bg-white/10 rounded-xl transition-colors text-white/80 hover:text-white disabled:opacity-20" title="Redo">
                        <i data-lucide="redo-2" class="w-5 h-5"></i>
                    </button>
                    <button id="clear_btn" class="p-2 hover:bg-white/10 rounded-xl transition-colors text-white/80 hover:text-white group" title="Clear Canvas">
                        <i data-lucide="trash-2" class="w-5 h-5 group-hover:rotate-12 transition-transform"></i>
                    </button>
                </div>
                <div class="w-px h-8 bg-white/10"></div>
                
                <!-- Info Toggle -->
                <button id="info_btn" class="p-2 hover:bg-white/10 rounded-xl transition-colors text-cyan-400" title="Instructions">
                    <i data-lucide="help-circle" class="w-6 h-6"></i>
                </button>
            </div>
        </div>

        <!-- Instructions -->
        <div id="instructions_panel" class="mt-auto pointer-events-auto transition-all duration-500 transform translate-y-10 opacity-0 pointer-events-none">
            <div class="max-w-md bg-black/60 backdrop-blur-3xl border border-white/10 rounded-3xl p-8 shadow-2xl relative overflow-hidden group">
                <div class="absolute top-0 right-0 p-6 opacity-10 group-hover:opacity-20 transition-opacity">
                    <i data-lucide="info" class="w-16 h-16"></i>
                </div>
                <h3 class="text-2xl font-black mb-6 flex items-center gap-3 uppercase tracking-tight italic">
                    How to Paint
                </h3>
                <ul class="space-y-5 text-sm text-white/60">
                    <li class="flex items-start gap-4">
                        <div class="w-7 h-7 rounded-full bg-cyan-500/20 flex items-center justify-center text-cyan-400 font-bold text-xs shrink-0 border border-cyan-500/30">1</div>
                        <p>Raise your <span class="text-white font-bold">Index Finger</span> to start drawing on the digital canvas.</p>
                    </li>
                    <li class="flex items-start gap-4">
                        <div class="w-7 h-7 rounded-full bg-cyan-500/20 flex items-center justify-center text-cyan-400 font-bold text-xs shrink-0 border border-cyan-500/30">2</div>
                        <p>Lower your finger or <span class="text-white font-bold">Make a Fist</span> to pause your brush stroke.</p>
                    </li>
                    <li class="flex items-start gap-4">
                        <div class="w-7 h-7 rounded-full bg-cyan-500/20 flex items-center justify-center text-cyan-400 font-bold text-xs shrink-0 border border-cyan-500/30">3</div>
                        <p>Use the <span class="text-white font-bold">Top Menu</span> to switch colors or wipe the canvas clean.</p>
                    </li>
                </ul>
                <button id="close_instructions" class="mt-8 w-full py-4 bg-white text-black font-black rounded-2xl hover:bg-cyan-400 transition-all active:scale-95 uppercase text-xs tracking-[0.2em]">
                    Start Painting
                </button>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading_overlay" class="fixed inset-0 z-50 flex flex-col items-center justify-center bg-black backdrop-blur-md transition-opacity duration-700">
        <div class="relative w-24 h-24 mb-10">
            <div class="absolute inset-0 border-4 border-cyan-500/10 rounded-full"></div>
            <div class="absolute inset-0 border-4 border-cyan-500 rounded-full border-t-transparent animate-spin"></div>
            <i data-lucide="palette" class="absolute inset-0 m-auto w-10 h-10 text-cyan-500 animate-pulse"></i>
        </div>
        <h2 class="text-3xl font-black tracking-tighter uppercase italic text-white mb-3">
            Initializing 
        </h2>
        <p class="text-white/40 text-[10px] uppercase tracking-[0.5em] font-bold animate-pulse-soft mono">
            Loading Hand Tracking Models...
        </p>
    </div>

    <!-- Error Overlay -->
    <div id="error_overlay" class="fixed inset-0 z-50 hidden flex flex-col items-center justify-center bg-black/95 backdrop-blur-xl p-10 text-center">
        <div class="w-24 h-24 bg-red-500/10 rounded-full flex items-center justify-center mb-8 border border-red-500/20">
            <i data-lucide="camera-off" class="w-10 h-10 text-red-500"></i>
        </div>
        <h2 class="text-4xl font-black tracking-tighter uppercase italic text-white mb-4">
            Camera Required
        </h2>
        <p id="error_msg" class="text-white/60 max-w-md mb-10 leading-relaxed text-sm">
            We need camera access to track your hand gestures. Please enable permissions and refresh.
        </p>
        <button onclick="window.location.reload()" class="px-10 py-4 bg-white text-black font-black rounded-2xl hover:bg-cyan-400 transition-all active:scale-95 uppercase tracking-[0.2em] text-xs">
            Refresh & Retry
        </button>
    </div>

    <script>
        // Initialize Lucide Icons
        lucide.createIcons();

        const videoElement = document.getElementById('input_video');
        const bgCanvas = document.getElementById('bg_canvas');
        const drawingCanvas = document.getElementById('drawing_canvas');
        const bgCtx = bgCanvas.getContext('2d');
        const drawingCtx = drawingCanvas.getContext('2d');
        
        const statusDot = document.getElementById('status_dot');
        const statusText = document.getElementById('status_text');
        const loadingOverlay = document.getElementById('loading_overlay');
        const errorOverlay = document.getElementById('error_overlay');
        const errorMsg = document.getElementById('error_msg');
        const instructionsPanel = document.getElementById('instructions_panel');
        const infoBtn = document.getElementById('info_btn');
        const undoBtn = document.getElementById('undo_btn');
        const redoBtn = document.getElementById('redo_btn');
        const brushSizeInput = document.getElementById('brush_size');
        const brushSizeVal = document.getElementById('brush_size_val');
        
        let currentColor = '#00ffff';
        let brushSize = 10;
        let isDrawing = false;
        let lastPoint = null;
        let handsLoaded = false;
        
        // Smoothing state
        let smoothedX = 0;
        let smoothedY = 0;
        const smoothingAlpha = 0.3; // Lower = smoother but more lag

        // History state
        let undoStack = [];
        let redoStack = [];
        const MAX_HISTORY = 20;

        function saveState() {
            undoStack.push(drawingCanvas.toDataURL());
            if (undoStack.length > MAX_HISTORY) undoStack.shift();
            redoStack = []; // Clear redo stack on new action
            updateHistoryButtons();
        }

        function undo() {
            if (undoStack.length === 0) return;
            redoStack.push(drawingCanvas.toDataURL());
            const state = undoStack.pop();
            restoreState(state);
            updateHistoryButtons();
        }

        function redo() {
            if (redoStack.length === 0) return;
            undoStack.push(drawingCanvas.toDataURL());
            const state = redoStack.pop();
            restoreState(state);
            updateHistoryButtons();
        }

        function restoreState(dataUrl) {
            const img = new Image();
            img.onload = () => {
                drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                drawingCtx.drawImage(img, 0, 0);
            };
            img.src = dataUrl;
        }

        function updateHistoryButtons() {
            undoBtn.disabled = undoStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
        }

        // Brush Size Logic
        brushSizeInput.addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            brushSizeVal.innerText = brushSize;
        });

        // History Buttons Logic
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);
        updateHistoryButtons();

        // Color Picker Logic
        document.querySelectorAll('#color_picker button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('#color_picker button').forEach(b => b.classList.remove('btn-active'));
                btn.classList.add('btn-active');
                currentColor = btn.dataset.color;
            });
        });

        // Clear Canvas
        document.getElementById('clear_btn').addEventListener('click', () => {
            saveState();
            drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
        });

        // Toggle Instructions
        function toggleInstructions() {
            const isHidden = instructionsPanel.classList.contains('opacity-0');
            if (isHidden) {
                instructionsPanel.classList.remove('translate-y-10', 'opacity-0', 'pointer-events-none');
            } else {
                instructionsPanel.classList.add('translate-y-10', 'opacity-0', 'pointer-events-none');
            }
        }

        infoBtn.addEventListener('click', toggleInstructions);
        document.getElementById('close_instructions').addEventListener('click', toggleInstructions);

        // Resize Handling
        function resize() {
            const { innerWidth, innerHeight } = window;
            
            // Save current drawing
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = drawingCanvas.width;
            tempCanvas.height = drawingCanvas.height;
            tempCanvas.getContext('2d').drawImage(drawingCanvas, 0, 0);
            
            bgCanvas.width = innerWidth;
            bgCanvas.height = innerHeight;
            drawingCanvas.width = innerWidth;
            drawingCanvas.height = innerHeight;
            
            // Restore drawing
            drawingCtx.drawImage(tempCanvas, 0, 0);
        }
        window.addEventListener('resize', resize);
        resize();

        // MediaPipe Results Handler
        function onResults(results) {
            if (!handsLoaded) {
                handsLoaded = true;
                loadingOverlay.style.opacity = '0';
                setTimeout(() => loadingOverlay.style.display = 'none', 700);
            }

            // 1. Draw mirrored video background
            bgCtx.save();
            bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
            bgCtx.scale(-1, 1);
            bgCtx.drawImage(results.image, -bgCanvas.width, 0, bgCanvas.width, bgCanvas.height);
            bgCtx.restore();

            // 2. Gesture logic
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const indexTip = landmarks[8];
                const indexPip = landmarks[6];
                const middleTip = landmarks[12];
                
                const rawX = (1 - indexTip.x) * bgCanvas.width;
                const rawY = indexTip.y * bgCanvas.height;

                // Apply Smoothing (EMA)
                if (smoothedX === 0 && smoothedY === 0) {
                    smoothedX = rawX;
                    smoothedY = rawY;
                } else {
                    smoothedX = smoothingAlpha * rawX + (1 - smoothingAlpha) * smoothedX;
                    smoothedY = smoothingAlpha * rawY + (1 - smoothingAlpha) * smoothedY;
                }

                const x = smoothedX;
                const y = smoothedY;

                // Gesture: Index finger pointing up, middle finger down
                const isPointing = indexTip.y < indexPip.y && indexTip.y < middleTip.y;

                // Visual feedback for cursor on background canvas
                bgCtx.beginPath();
                bgCtx.arc(x, y, brushSize / 2 + 5, 0, Math.PI * 2);
                bgCtx.fillStyle = isPointing ? currentColor : 'rgba(255,255,255,0.3)';
                bgCtx.fill();
                bgCtx.strokeStyle = 'white';
                bgCtx.lineWidth = 2;
                bgCtx.stroke();

                if (isPointing) {
                    statusDot.classList.replace('bg-red-500', 'bg-green-500');
                    statusDot.classList.add('shadow-[0_0_10px_#22c55e]');
                    statusText.innerText = 'Painting Active';
                    statusText.classList.replace('opacity-40', 'opacity-100');

                    if (!lastPoint) {
                        saveState(); // Save state before starting a new stroke
                        lastPoint = { x, y };
                    } else {
                        drawingCtx.beginPath();
                        drawingCtx.moveTo(lastPoint.x, lastPoint.y);
                        drawingCtx.lineTo(x, y);
                        drawingCtx.strokeStyle = currentColor;
                        drawingCtx.lineWidth = brushSize;
                        drawingCtx.lineCap = 'round';
                        drawingCtx.lineJoin = 'round';
                        
                        // Glow effect
                        drawingCtx.shadowBlur = brushSize * 1.5;
                        drawingCtx.shadowColor = currentColor;
                        
                        drawingCtx.stroke();
                        lastPoint = { x, y };
                    }
                } else {
                    resetStatus();
                    lastPoint = null;
                }
            } else {
                resetStatus();
                lastPoint = null;
                // Reset smoothing when hand is lost to prevent "jumping" when hand reappears
                smoothedX = 0;
                smoothedY = 0;
            }
        }

        function resetStatus() {
            statusDot.classList.replace('bg-green-500', 'bg-red-500');
            statusDot.classList.remove('shadow-[0_0_10px_#22c55e]');
            statusText.innerText = 'Waiting for Gesture';
            statusText.classList.replace('opacity-100', 'opacity-40');
        }

        // Initialize MediaPipe
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        // Start Camera
        async function init() {
            try {
                // Check for camera permission explicitly
                await navigator.mediaDevices.getUserMedia({ video: true });
                
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({ image: videoElement });
                    },
                    width: 1280,
                    height: 720
                });
                camera.start();
            } catch (err) {
                console.error('Camera Error:', err);
                loadingOverlay.style.display = 'none';
                errorOverlay.classList.remove('hidden');
                if (err.name === 'NotAllowedError') {
                    errorMsg.innerText = "Camera access was denied. Please enable permissions in your browser settings and refresh the page.";
                }
            }
        }

        init();
    </script>
</body>
</html>
